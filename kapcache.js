export const HEADER={name:"Cacher",version:"0.0.4"};const o=r=>new Promise(e=>setTimeout(e,r));export class Cacher{cacheName;_cache;set cache(e){this._cache=e,localStorage.setItem(this.cacheName,JSON.stringify(e)),this.initialized=!0}get cache(){return this._cache}initialized=!1;static nsBuilder(e,a){return`${e}~${a}`}constructor(e){this.cacheName=e}ensureIsInit(){if(!this.initialized)throw new Error("Cache not initialized, will not function without cache")}async init(){this.cache=await caches.open(this.cacheName),this.initialized=!0}createNamespace(e){return this.ensureIsInit(),new CacherNamespace(this,e)}createSpriteCacher(){return this.ensureIsInit(),new window.SpriteCacher(this)}}export class CacherNamespace{namespace;parent;cache;constructor(e,a){e.ensureIsInit(),this.namespace=a,this.parent=e,this.cache=()=>this.parent.cache}nsBuilder=e=>Cacher.nsBuilder(this.namespace,e);async get(e){return await this.cache().match(this.nsBuilder(e))}async put(e,a){await this.cache().put(this.nsBuilder(e),a)}makeRollout(e,a=0){return new CacheRollout(this,e,a)}}export class CacheRollout{rolloutList;rolloutInterval;parent;cache;constructor(e,a,t=0){this.rolloutList=a,this.rolloutInterval=t,this.parent=e,this.cache=()=>e.cache()}async rollout(e){return await Promise.all(this.rolloutList.map(async t=>{const i=this.parent.nsBuilder(t),s=await this.cache().match(i),c=await e(t,i,s,this);return this.rolloutInterval>0&&await o(this.rolloutInterval),c}))}async tossBrokenCaches(e){let a=await this.cache().keys(),t=[];for(let i of a){let s=i.url.split("/").pop()?.split("~")[1];e.includes(s)||t.push(s)}for(let i of t)await this.cache().delete(i)}}export function CacherPlugin(r){class e{namespace;parent;CNS;cache;nsBuilder=t=>Cacher.nsBuilder(this.namespace,t);constructor(t){this.namespace="sprite",this.parent=t,this.CNS=new CacherNamespace(t,this.namespace),this.cache=()=>this.CNS.cache()}async fetchAndCacheSprite(t){const s=await(await fetch(`./sprites/${t}.png`)).blob(),c=URL.createObjectURL(s);let n=new Response(s);return await this.CNS.put(t,n),await r.loadSprite(t,c),n}async loadCachedSprite(t,i){const s=new FileReader;return s.onload=async()=>await r.loadSprite(t,s.result).catch(async c=>{console.error(`Failed to load cached sprite for ${t}:`,c),i=await this.fetchAndCacheSprite(t)}),s.readAsDataURL(await i.blob()),i}async rollout(t,i=0){let s=this.CNS.makeRollout(t,i),c=await s.rollout(async(n,l,h,u)=>{h?await this.loadCachedSprite(n,h):await this.fetchAndCacheSprite(n)});return await s.tossBrokenCaches(t),c}}return{...HEADER,Cacher,CacherNamespace,CacheRollout,SpriteCacher:e}}
//# sourceMappingURL=kapcache.js.map
